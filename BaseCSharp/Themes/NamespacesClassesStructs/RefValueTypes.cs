namespace BaseCSharp.Themes.NamespacesClassesStructs;

public class RefValueTypes
{
    public struct ExampleStruct
    {
        public int x;
        public int y;
        public ExampleClass exClass;
    }

    public class ExampleClass
    {
        public int x;
        public int y;
    }

    public void Run()
    {
        Console.WriteLine("++++++++ ССЫЛОЧНЫЕ И ЗНАЧИМЫЕ ТИПЫ ++++++++");
        // Ссылочные типы string interface class delegate - только эти
        // Значимые типы int struct char float .... все остальные

        // Значимые типы размещаются в стеке
        // Стек растет снизу вверх (те новый элемент рассполагается поверх предыдущего)
        // Жизнь переменных в стеке ограничена контекстом (те зашли в функцию - выделилась память вышли - освободилась)
        // Стек - небольшая область памяти в адресном пространстве
        // Фрейм стека - это часть в стеке которая выделяется для каждой функции при ее вызове
        // После завершения выполнения функции - та часть стека будет использована для другой функции и тд
        // В стек помещаются сами значения (то есть 2 или true или 'A')

        // ССылочные типы размещаются в куче
        // Куча это - остальная часть памяти выделенной процессу
        // Для ссылочных типов сам объект размещается в куче а ссылка на него записывается в стеке
        // Когда больше действующих ссылок на этот объект - сборщик мусора помечает что этот участок памяти свободен


        // Составные типы
        var struct1 = new ExampleStruct(); // структура - значимый тип - в стеке
        ExampleStruct struct2; // - можно без оператора new (как примитив)
        var class1 = new ExampleClass(); // класс - ссылочный тип - в куче, а ссылка на него в стеке
        // оператор new выделяет память и возвращает ссылку - адрес в куче для данного объекта

        ExampleStruct struct3; // сруктура - все поля - в стеке, но сам класс в куче, а в стеке только ссылка на него
        struct3.x = 10; //- в стеке
        struct3.y = 12; // - в стеке
        struct3.exClass = new ExampleClass
            { x = 5, y = 8 }; // - сам класс со всеми полями в куче а ссылка на него в стеке

        // Копирование значений
        // при копировании значимые типы - получают копию значений
        int a = 4; // в стеке записано 4
        int b = a; // в стеке записано 4 - это другая четверка, а не та что в переменной a
        Console.WriteLine($"{a} --- {b}");
        a = 8; // а поменяется но b так и останется 4 потому что там просто другое значение записано
        Console.WriteLine($"{a} --- {b}");

        var struct4 = new ExampleStruct { x = 5, y = 10 }; // одна структура
        ExampleStruct
            struct5 = struct4; // другая структура, просто скопирована с предыдущей (будут изменятся независимо)
        struct4.y = 30; // поменяется только в 4 структуре в 5 - без изменений

        // при копировании ссылочные типы - получают КОПИЮ ССЫЛКИ на этот объект, но не копируется сам объект
        // те изменение в 1 (любом из) объекте повлияет и на другой
        // пример
        var class2 = new ExampleClass { x = 10, y = 20 }; // в куче, в стеке ссылка на адрес в переменной class2
        var class3 = class2; // скопировалась ссылка в class3, но не скопировался объект в куче
        Console.WriteLine($"До изменения значения class3.x {class3.x}");
        class3.x = 20;
        Console.WriteLine($"После изменения значения class2: {class2.x}"); // значение тоже поменялось тк объект один
        // Нужно иметь ввиду что изменение ссылочного объекта повлияет на все скопированные
        // Чтобы избежать нужно выполнять глубокое копирование

        // Ссылочные типы внутри значимых типов
        // Если внутри структур ест ссылочные поля, то действуют те же правила - изменение ссылочного типа повлияет на всех

        // Объекты классов в качестве параметров метода

        // можно изменять поля объекта внутри метода но не сам объект
        ExampleClass class4 = new() { x = 10, y = 20 };
        ChangeClass(class4);
        Console.WriteLine($"Поменялось поле, но не перезаписался новым объектом {class4.x} {class4.y}");

        void ChangeClass(ExampleClass example)
        {
            class4.x = 100; // сработает - поменяли поле класса по ссылке на тот объект
            example = new ExampleClass() { x = 50, y = 60 }; // не сработает тк перезаписали ссылку новым объектом
            Console.WriteLine(
                $"Внутри метода теперь параметр указывает на другой объект тк перезаписалась ссылка {example.y} {example.x}");
        }
        
        
        // чтобы перезаписать объект снаружи другим нужно передавать с ref модификатором
        ExampleClass class5 = new() { x = 10, y = 20 };
        ChangeClass2(ref class5);
        Console.WriteLine($"{class5.x} {class5.y}"); // новая ссылка перезаписана внутри метода
        void ChangeClass2(ref ExampleClass example)
        {
            example = new ExampleClass { x = 100, y = 200 }; // теперь сработает тк передан с ref
        }
    }
}